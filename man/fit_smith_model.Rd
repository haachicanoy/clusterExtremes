% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_smith_model.R
\name{fit_smith_model}
\alias{fit_smith_model}
\title{Fit smith max-stable model to bootstrap samples}
\usage{
fit_smith_model(data, knn_info, medoid_indexes, use_id, grid, min_class_prob,
  high_class_prob, frech_bool = TRUE, num_samps, samp_size, min_common_obs,
  min_pairs = choose(10, 2), ratio_threshold = 0.1, ellipse_alpha, max_iter,
  save_output = FALSE, output_dir = NULL, reference_id = NULL)
}
\arguments{
\item{data}{a data frame with columns labelled by the station id, and
rows corresponding to block maximum observation at that station}

\item{knn_info}{data frame with columns x, y, cluster_id, knn_id and prob.
The set of cluster_id and knn_id must be the same. The column prob is
the probability of assigning that station to under the classification.}

\item{medoid_indexes}{index of the medoid in the knn_info data frame.
should update this so it is a data frame for reference not an index.}

\item{use_id}{the cluster_id/knn_id of the region we are considering}

\item{grid}{a data frame that describes a grid, columns of x, y and knn_id.
Must cover the region of interest}

\item{min_class_prob}{for the station to be considered in the fitting it must
have been assigned under the classification with this minimum probability}

\item{high_class_prob}{for the station to be considered in the fitting it must
not be different to the rest of the stations in the region, if the probability of
classificaiton is high, but the cluster id and classification id are different
we discard the station}

\item{frech_bool}{(default = TRUE) is the data frechet distributed, otherwise we
assume loc, scale and shape parameters constant}

\item{num_samps}{number of times to repeat the fitting of the smith model}

\item{samp_size}{number of stations used in fitting}

\item{min_common_obs}{minimum number of common observation for get_pair_weights()}

\item{min_pairs}{minimum number of pairs recommonded for fitting}

\item{ratio_threshold}{ratio of the elliptical axes must exceed this,
or convergence is supsected to have failed (default is 0.1, for 1:10)}

\item{ellipse_alpha}{if paramter values are outside this alpha level,
we chose to repeat fitting with better initialisation, two-sided, therefore
must take values in range 0 to 0.5}

\item{max_iter}{(integer) maximum number of times to repeat fitting with improved
initialisation}

\item{save_output}{(boolean) default is FALSE, save out the model fits}

\item{output_dir}{directory to save output (default is NULL)}

\item{reference_id}{if reference_id is NULL defaults to user id, is an index to
use in the filename for referencing the output}
}
\value{
Returns the a data frame with columns block, which is the year, and p_value.
}
\description{
We have classified a gridded region based on a clustering outpput. The classification
step was necessary to identify region boundaries. This function fits a max-stable model
to obtain the dependence structure for the region. We sample from suitable stations to
obtain multiple realisations of the dependence structure.
}
\details{
Of note, under the classification it is possible to have disjoint regions
classified similarly. For sampling, we only consider stations that are classified
similiarly and connected to the medoid identified in clustering. We also only
consider stations that were assigned to that region with a minimum probability.
After the initial fitting, we consider two basic diagnostics to check if the
optimisation converged. We compare the ratio of the two axes of the ellipses.
If the ratio is too small, we initial the start values and repeat the fitting.
We also repeat the fitting if the fitted parameter is 'too far'
from what we consider 'normal'.
}
\examples{
# generate an arbitary set of points
set.seed(1)
n.site <- 600
locations <- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) <- c("lon", "lat")

# create a medoid
medoid_coords = c(3,3)
location = c(locations, rbind(medoid_coords))
medoid = 601

# create a test clustering and classificaiton dataframe
# make two disjoint regions
# make some of the probabilities less than 0.5
knn_info <- data.frame(x = locations[,1], y = locations[,2]) \%>\%
 mutate(knn_id = 1) \%>\%
 mutate(cluster_id = 1) \%>\%
 mutate(prob = 1) \%>\%
 mutate(knn_id = if_else((x < 6 & y < 6) | (x > 7 & y > 7), 2, knn_id)) \%>\%
 mutate(cluster_id = if_else((x < 6 & y < 6) | (x > 7 & y > 7), 2, cluster_id)) \%>\%
 mutate(prob = if_else(x < 5.5 & y < 5.5, prob, 0.4))

# generate some data
data <- rmaxstab(100, locations, cov.mod = "gauss", cov11 = 1, cov12 = 0, cov22 = 1)

# create grid covering the coordiantes
grid <- get_grid_for_classification(coords = knn_info \%>\% select(x,y),
                                   grid_space = 0.25, restrict_aus = FALSE)
names(grid) = c("x", "y")

# mimic the classificaiton of the knn_info
grid <- grid \%>\%
 mutate(knn_id = 1) \%>\%
 mutate(knn_id = if_else((x < 6 & y < 6) | (x > 7 & y > 7), 2, knn_id))

# fit the smith model
model_list <- fit_smith_model(data = data, knn_info = knn_info,
                             medoid_indexes = c(100, 601), use_id = 2,
                             grid, min_class_prob = 0.5,
                             frech_bool = TRUE,
                             num_samps = 10, samp_size = 20,
                             min_common_obs = 0, min_pairs = 0,
                             ratio_threshold = 0.1, ellipse_alpha= 0.05,
                             max_iter = 3,
                             save_output = FALSE, output_dir = NULL,
                             reference_id = NULL)

# visualise the result
medoid_coords = data.frame(x=3, y=3)
ellipse_df <- get_ellipse_from_smith_model_list(model_list, medoid = medoid_coords)

# plot result
ell_plot <- ggplot(data = ellipse_df) +
 geom_path(aes(x=x, y =y, group = sim_index), alpha = 0.25) +
 theme_bw()
ell_plot

}
